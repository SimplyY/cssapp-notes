@(编程读书合集)

# CSAPP

## 译者序

#### 书籍概述及优点

![image](https://cloud.githubusercontent.com/assets/8455579/8894523/fb892fea-33eb-11e5-88ba-5583e72495bd.png)


#### 序的总结
![image](https://cloud.githubusercontent.com/assets/8455579/8894524/0470e24c-33ec-11e5-82f4-96cac1dbe1f6.png)


#### 阅读心得
1. **理解底层** ，**构造层次型** 的计算机系统，从而设计更高效、健壮的计算机程序。
2. **桥梁**：系统性的学习计算机指令、虚拟存储器、编译原理、动态加载库、操作系统等，难得的跨领域贯穿计算机系统各个知识的书籍。
3. 接触计算机科学的各种领域，增加知识的广度和对计算机 **系统性** 的了解。

## 第一章：计算机系统漫游


##### 概述
![image](https://cloud.githubusercontent.com/assets/8455579/8894529/2290c242-33ec-11e5-8ebd-f8a6e99d308a.png)


##### 目录
![image](https://cloud.githubusercontent.com/assets/8455579/8894530/27d5d3e6-33ec-11e5-92f5-948a01bf0f85.png)


#### 阅读心得
这一章会很有意思

### 1.1 信息就是位 + 上下文
![image](https://cloud.githubusercontent.com/assets/8455579/8894531/339842ae-33ec-11e5-978e-0dcb09af0ce1.png)



#### 阅读心得

1. 计算机里的所有的程序、软件、视频、图片全是 `0 1` 和组成。之所以 `0 1` 能表示、储存东西，因为这些都是数据、是信息。而 **位 + 上下文**  为 `0 1` 使每一个 `0 1` 都有了它自己的意义，*就好比世间的绝大多数事物都是由原子和电子组成一样*。
2. 了解底层的编码的好处： 知道**本质的规律**，才可以 **避免一些错误的使用，** 而且所谓的编码 **只是对信息的一种模拟**，比如计算机对1/3这个值都无法精确模拟

3. 但是编码过于底层，`0 1` 对于人类，几乎是不可读的，更别谈去 *储存、处理、展示* 数据了。所以就发明了 *汇编语言、高级编程语言* 来对其底层封装。

### 1.2 程序被其他程序翻译成不同格式
![image](https://cloud.githubusercontent.com/assets/8455579/8894532/3a1014b8-33ec-11e5-8a60-5836b44cd9f0.png)


### 1.2 程序被其他程序翻译成不同格式
![image](https://cloud.githubusercontent.com/assets/8455579/8985980/78d73d98-370c-11e5-8eef-be98a38b71f6.png)



#### 心得
1. 程序的**编译系统**就是这四个阶段组成
	1. 预处理器：将 *头文件内容* 插入程序文本`hello.c`变成`hello.i`
	2. 编译器：将`hello.i`编译成汇编文件`hello.s`
	3. 汇编器：将`hello.s`翻译成 **机器语言指令** ，并打包到 **二进制文件** `hello.o`中，*切记是机器语言二进制指令不是字符*
	4. 链接器：将`hello.o`与引入的库中的函数（比如`printf`）的二进制文件`print.o`以某种方式合并在一起。此时就得到了`hello`文件，这是一个可执行的目标文件，可以被加载到内存中，被系统（硬件）调用。


### 1.3 了解编译系统如何工作的是大有益处的
1. 优化程序性能：无论是语言的语法还是我们写的函数，都是一种对 **底层的抽象** ，抽象不可避免的是 *信息的减少* （有好处，使我们的精力更集中于 **更关键的事** 上），这样以来，一件事有两种或更多种做法的时候，必然，有性能高低，并且我们能知道为什么，知道如何选择。 *就好比人类上万年前就发明了火，在对其原理的深刻认识后现在才能有打火机，无论是如何用更好，还是突破性的进展都和原理息息相关。*
2. 理解链接时出现的错误。还是由于抽象性的原因，我们写程序的时候只是在被语法限制，但实际上语法是一种抽象，不知道原理，，比如 `include` 或者 `import`，最容易在构建大型软件系统时出错，因为人总是会犯错，项目复杂性越高，错误越多，而不知原理，有的错误甚至无法解决，或者花大量时间。
3. 避免安全漏洞。原因与前者类似，比如 **缓冲区溢出** ，这与数据的存放在 **内存的堆栈原理** 有关。


### 1.4 处理器读并解释存储在存储器中的指令

此时我们的 hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并存放在磁盘上。那么此时，可执行程序到底是如何运行的呢。

首先让我们了解一下系统的硬件组成的一些基本知识（先了解即可）

![image](https://cloud.githubusercontent.com/assets/8455579/8985999/91516524-370c-11e5-9698-2eb888837752.png)

![image](https://cloud.githubusercontent.com/assets/8455579/8986004/962cc2b4-370c-11e5-8f57-6bdf977e5355.png)


了解了基本的硬件知识后接下来，**最重要的来了可执行程序的运行**

![image](https://cloud.githubusercontent.com/assets/8455579/8986011/9d6472c0-370c-11e5-8b26-1aa530782378.png)



#### 心得：
#####  了解 cpu 的结构，cpu 的对数据的操作有两种，高速储存、计算：

0. **总线接口** 用来和外界传输数据
1. 其中 **PC** 指向 **主存储器**， 处理器从指向位置读取数据。
2. **寄存器文件** 储存数据
3.  **ALU（算术逻辑单元）** 用来计算新的数据和地址值
4. **寄存器 和 ALU** 组合使用就可以达到 **存放并执行** 的功能。

##### 程序的运行所经过的过程：
1. 外部输入命令（或者可以理解成双击 exe） ，主储存器开始加载可执行文件 `hello` 也就是将其文件中的机器代码（指令）和数据从磁盘复制到主存
2. 处理器通过总线接口，得到程序的指令和数据，并开始执行。
3. 由于 `printf` 转的指令会将执行的结果输出到`io` 设备（也就是显示屏）于是控制台看到了 `hello, world`
